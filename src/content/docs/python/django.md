---
title: Django
---

## Installation

It's recommended to create a virtual environment with `python -m venv .venv` and then activate it with `source .venv/bin/activate` before installing Django. This will keep your installed packages separate from the rest of the system, where the versions might otherwise conflict. You can deactivate the virtual environment with `deactivate`.

Virtual environments are not Docker containers, they only isolate Python packages and still rely on the system's installed version of Python.

You can install Django with `pip install django`, then start a new project with `django-admin startproject mysite`. Remember to append a dot if you don't want to create a new directory. You'll also need `python manage.py migrate` to run the initial migrations which come with the framework, then you can use `python manage.py runserver` to start the dev server.

You can generate 'requirements.txt' to track your dependencies with `pip freeze > requirements.txt`.

### Dockerization

I'm gonna use the Alpine images because I hate myself.

#### Environment Variables

`PIP_DISABLE_PIP_VERSION_CHECK=1` - Prevents `pip` from checking for updates.
`PYTHONDONTWRITEBYTECODE=1` - Prevents Python from writing .pyc files to disk.
`PYTHONUNBUFFERED=1` - Prevents Python from buffering stdout and stderr.

## Commands

### `manage.py`

`createsuperuser` - Creates a superuser, will prompt for username, email and password.
`makemigrations <app_name>` - Creates a migration, optionally scoped to an app.
`migrate` - Runs the migrations.
`runserver` - Starts the development server.
`shell` - Starts the shell.
`test` - Runs the test suite.

## Apps

Apps are similar to the concept of a resource in Rails, they're a folder with their own urls, models, views, etc.

Start a new app with `python manage.py startapp myapp` then add it to `INSTALLED APPS` in `settings.py`. Apps are loaded from this list top to bottom, so make sure to put the app below any it depends on.

You'll also need to create a route for it in `urls.py`.

## Models

### User Model

Django comes with a default user model, as well as an admin dashboard with permissions/groups etc. Very handy. However, since you're most likely going to want to make some changes to this model and it's apparently a pain to change once you run the initial migrations, you'll want to create a custom user model.

This can be done by extending either `AbstractUser` or `AbstractBaseUser` and adding the fields you want. `AbstractUser` is easier, but `AbstractBaseUser` is a bit more flexible. Seems it's fine to start with the easier one and switch later as it's not a big hassle to do so.

There are 4 main steps to adding a custom user model:

1. Create the CustomUser model

- Generate the app with a name like 'accounts'
- Define a CustomUser model in the app's `models.py`
- Generate a migration to create the table for your model

2. Add it to `AUTH_USER_MODEL` in `settings.py`

- Add `accounts.apps.AccountsConfig` to `INSTALLED_APPS`
- Append `AUTH_USER_MODEL = 'accounts.CustomUser'` to `settings.py`

3. Customise `UserCreationForm` and `UserChangeForm`

- Create 'accounts/forms.py' and import `get_user_model` plus the two forms to be modified
- Extend the forms as needed, remembering to set the model with `model = get_user_model()` and that password fields are included implicitly

4. Add the custom user model to `admin.py`

- Update `admin.py` with imports for `get_user_model` as well as `UserAdmin` and the new custom forms you just customized
- Create a `CustomUserAdmin` class that extends `UserAdmin` and register it with `admin.site.register(CustomUser, CustomUserAdmin)`

### Migrations

## Testing

Uses `unittest` from Python stdlib by default, test files are autogenerated with apps. Run with `python manage.py test`.

### unittest

Methods to be run as tests must be prefixed with `test_`, and should have a descriptive name.

### pytest

You'll wanna use `pytest-django` for handy extra features, which will also install the latest pytest as a dependency. You can then run tests with just `pytest`.

Doesn't have the fancy asserts like `assertEqual` and `assertIn` that `unittest` has, but apparently the output on errors is more detailed and it's more widely used in the general python community.

#### marks

Marks are decorators that change the behavior of a test or group of tests. They are prefixed with `@pytest.mark.<mark>`, and require pytest to be imported. To apply them to a whole class of test, add the mark right before the class is defined.

If your test needs the database, you can mark it with `@pytest.mark.django_db`.
